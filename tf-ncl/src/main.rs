use clap::Parser;
use core::fmt;
use pretty::{BoxAllocator, BoxDoc, Pretty};
use std::{
    collections::HashMap,
    fs,
    io::{self, stdout, Write},
    path::{Path, PathBuf},
};
use tf_ncl::{
    intermediate::{GoSchema, IntoWithProviders, Providers, WithProviders},
    nickel::{AsNickel, AsNickelTerm},
    nickel_builder::{self as builder, Types},
    terraform::TFSchema,
};

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Terraform schema, generated by schema-merge
    #[arg(value_name = "SCHEMA")]
    schema: PathBuf,
    /// Output directory for Nickel schema files
    #[arg(value_name = "DIRECTORY")]
    output_directory: PathBuf,
}

fn get_schema(opts: &Args) -> anyhow::Result<GoSchema> {
    Ok(serde_json::from_reader(std::fs::File::open(&opts.schema)?)?)
}

struct RenderableSchema<'a> {
    schemas: HashMap<PathBuf, BoxDoc<'a>>,
}

impl<'a> RenderableSchema<'a> {
    fn render(&self, directory: &Path) -> anyhow::Result<()> {
        let tfncl_lib = include_str!("../../ncl/lib.ncl");

        fs::create_dir_all(directory)?;
        fs::write(directory.join("lib.ncl"), tfncl_lib)?;

        for (p, doc) in self.schemas.iter() {
            let path = directory.join(p);
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent)?
            }
            write!(&mut fs::File::create(path)?, "{}", Display(doc))?;
        }

        //         write!(
        //             f,
        //             "{{
        //     Config = {{
        //         config | Schema,
        //         renderable_config = TfNcl.mkConfig config,
        //         ..
        //     }},
        //     Schema = {schema},
        //     TfNcl = {tfncl_lib} & {{
        //         mkConfig = fun v => v |> TfNcl.resolve_provider_computed |> TfNcl.remove_empty_records,
        //     }},
        //     required_providers = {required_providers}
        // }}",
        //             schema = Display(&self.schema),
        //             required_providers = Display(&self.providers),
        //         )?;
        Ok(())
    }
}

// impl<'a> From<WithProviders<GoSchema>> for RenderableSchema<'a> {
//     fn from(s: WithProviders<GoSchema>) -> Self {
//         RenderableSchema {
//             schema: s.as_nickel().pretty(&BoxAllocator).into_doc(),
//             providers: s.providers.as_nickel().pretty(&BoxAllocator).into_doc(),
//         }
//     }
// }

struct Display<'a, 'b>(&'b BoxDoc<'a>);

impl<'a, 'b> fmt::Display for Display<'a, 'b> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.render_fmt(80, f)
    }
}

fn main() -> anyhow::Result<()> {
    let opts = Args::parse();

    let go_schema = get_schema(&opts)?.push_down_computed_fields();

    let split_schema = dbg!(go_schema.split_for_provider("github")?);

    let mut schema_terms = HashMap::from([(
        PathBuf::from("core.nix"),
        split_schema.core_schema.as_nickel_term(),
    )]);
    split_schema.as_nickel(&mut schema_terms);

    let doc = RenderableSchema {
        schemas: schema_terms
            .into_iter()
            .map(|(k, v)| (k, v.pretty(&BoxAllocator).into_doc()))
            .collect(),
    };

    doc.render(&opts.output_directory)
}
